# Добавление тренировок через чат с AI

План реализации: пользователь в чате просит «поставь тренировку на завтра», AI задаёт уточняющие вопросы, собирает ответы и добавляет тренировку в календарь.

---

## 1. Текущее состояние

- **Чат с AI** — генерирует только текст. Модель получает контекст (профиль, план, статистика) и отвечает, но не выполняет действий.
- **API** — уже есть `add_training_day_by_date` (WeekController). Параметры: `date`, `type`, `description?`, `is_key_workout?`. Подробно — [ai-add-workouts-instruction.md](./ai-add-workouts-instruction.md).

---

## 2. Архитектура решения

### Вариант A: Скрытый блок в ответе (простой)

LLM добавляет в конец ответа специальный XML-подобный блок, который бэкенд парсит и выполняет:

```
Тренировка добавлена: завтра 8 км лёгкий бег.

<!-- ACTION add_training_day date=2026-02-12 type=easy description="Лёгкий бег 8 км" -->
```

Плюсы: не нужен function calling, работает с любым LLM. Минусы: возможны ложные срабатывания, модель может забыть формат.

### Вариант B: Два прохода (надёжнее)

1. Первый запрос — AI отвечает пользователю (и, при необходимости, задаёт вопросы).
2. Второй запрос — только если AI «решил» добавить тренировку: вызывается с промптом вида «Извлеки параметры для add_training_day из диалога и верни только JSON» или «Верни action block». Ответ парсится и выполняется.

### Вариант C: Function calling (если LM Studio поддерживает)

Если модель/API поддерживает tools/functions — передаём описание `add_training_day_by_date`, модель возвращает структурированный вызов. Надёжно, но зависит от API.

---

## 3. Рекомендуемый подход: Option A с валидацией

### 3.1 Формат action-блока

```
<!-- ACTION add_training_day date=YYYY-MM-DD type=TYPE description="..." -->
```

Правила:
- Блок — в конце сообщения AI, на отдельной строке.
- `date` — обязательно, формат Y-m-d.
- `type` — обязательно, из списка: rest, easy, long, tempo, interval, fartlek, other, sbu, race, control, marathon, free.
- `description` — как в AddTrainingModal: для бега «X км, темп MM:SS» или «X км или ЧЧ:ММ:СС, темп MM:SS»; для интервалов «Разминка 2 км. 5×1000 м (4:00), пауза 400 м трусцой. Заминка 2 км.»; для ОФП «Упражнение — 3×10, 20 кг»; для СБУ «Упражнение — 30 м». Темп в формате MM:SS мин/км.

### 3.2 Поток

1. Пользователь: «Поставь тренировку на завтра».
2. AI: «Какой тип? Лёгкий бег, темповый, интервалы? Сколько км?»
3. Пользователь: «Лёгкий, 8 км».
4. AI формирует ответ + action block. Бэкенд парсит блок, вызывает `add_training_day_by_date`, добавляет в ответ: «Готово, добавил 8 км лёгкого бега на 12 февраля».

### 3.3 System prompt — дополнения

Добавить в system prompt:

```
Если пользователь просит добавить/поставить/запланировать тренировку на дату:
1. Сначала уточни: тип (лёгкий, темповый, интервалы, ОФП и т.д.), дистанцию или длительность.
2. Если всё уточнено — в конце ответа добавь блок:
<!-- ACTION add_training_day date=YYYY-MM-DD type=TYPE description="..." -->
- date: Y-m-d (завтра = +1 день от сегодня)
- type: easy|long|tempo|interval|fartlek|rest|other|sbu|race|control|marathon|free
- description: краткое описание (опционально), в кавычках
Блок должен быть единственной строкой, без переносов внутри.
```

---

## 4. Реализация на бэкенде

### 4.1 Парсер action-блока

В `ChatService::sanitizeResponse()` или отдельном методе:

```php
private function parseAndExecuteActions(string $text, int $userId): array
{
    $actions = [];
    if (preg_match('/<!--\s*ACTION\s+add_training_day\s+([^>]+)\s*-->/', $text, $m)) {
        $params = [];
        foreach (['date', 'type', 'description'] as $key) {
            if (preg_match('/' . $key . '=([^\s"\']+|"[^"]*"|\'[^\']*\')/', $m[1], $pm)) {
                $params[$key] = trim($pm[1], '"\'');
            }
        }
        if (!empty($params['date']) && !empty($params['type'])) {
            $actions[] = ['add_training_day', $params];
        }
    }
    return $actions;
}
```

### 4.2 Выполнение action

После получения ответа LLM (в `sendMessageAndGetResponse` и в стриминге после сбора полного текста):

1. `$actions = $this->parseAndExecuteActions($fullContent, $userId)`
2. Для каждого action вызывать `WeekService::addTrainingDayByDate()` (через WeekController или напрямую сервис).
3. Удалить action block из текста перед сохранением в БД (чтобы пользователь не видел сырой блок).
4. При необходимости дописать к ответу: «Тренировка добавлена на {date}.»

### 4.3 Место вызова

- В `ChatService::sendMessageAndGetResponse()` — после `callLlm`, перед `addMessage`.
- В `ChatService::streamResponse()` — после `implode($chunks)`, перед `addMessage`.

---

## 5. Расширения (update, delete)

Позже можно добавить:

- `<!-- ACTION update_training_day day_id=123 type=easy description="..." -->`
- `<!-- ACTION delete_training_day day_id=123 -->`

Для update/delete нужен `day_id`. AI должен получать в контексте список плановых дней на неделю (из `loadTrainingPlanForUser` / `get_day`) или мы задаём правило: «Для изменения/удаления уточни дату и тип, мы найдём day_id по дате».

---

## 6. Безопасность

- Выполнять action только от имени текущего пользователя (`$userId`).
- Валидировать `type` по белому списку.
- Валидировать `date` (не слишком далеко в будущем, например не более 1 года).
- Не выполнять action, если модель явно пишет «не уверен» или «нужно уточнить» — можно проверять контекст перед блоком (эвристика).

---

## 7. Контекст для AI

Чтобы AI мог спрашивать «что уже стоит на завтра», в `ChatContextBuilder` стоит включать план текущей недели (уже есть в `formatPlanSummary`). При желании — добавить блок «План на следующую неделю» для удобства.

---

## 8. Чек-лист реализации

| Шаг | Описание |
|-----|----------|
| 1 | Дополнить system prompt правилами для action block |
| 2 | Реализовать `parseAndExecuteActions()` в ChatService |
| 3 | Вызывать парсер после получения ответа, выполнять add_training_day |
| 4 | Удалять action block из сохраняемого текста |
| 5 | Добавить подтверждение «Тренировка добавлена» в ответ |
| 6 | Протестировать сценарий: запрос → уточнения → добавление |
