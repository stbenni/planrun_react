# Перетаскивание в кастомайзере на мобильных: анализ вариантов

## Почему не работает «как на десктопе»

**HTML5 Drag and Drop API** (`draggable`, `dragstart` / `dragover` / `drop`) на мобильных:

- В мобильном Safari и многих Android-браузерах при касании и движении пальцем эти события **не вызываются** или ведут себя непредсказуемо.
- API изначально рассчитан на мышь; поддержка touch ограничена и сильно зависит от браузера и версии.
- Даже при частичной поддержке (например, long-press в некоторых браузерах) сценарий «перетащить на полоску между блоками» часто ломается.

Поэтому для мобильной версии нужен **отдельный механизм** на touch-событиях или на библиотеке, которая сама обрабатывает и мышь, и touch.

---

## Что уже сделано в проекте

Реализован **touch-фоллбек** в кастомайзере:

1. **Long press (~0.4 с)** по блоку → начало перетаскивания (без опоры на HTML5 DnD).
2. **touchmove** на `document` с `preventDefault()` → определение зоны сброса через `elementFromPoint`, подсветка полоски.
3. **touchend** → выполнение вставки в выбранную позицию (те же функции, что и при drop мышью).

Плюсы: без новых зависимостей, полный контроль, один и тот же layout-движок для мыши и touch.  
Минусы: свой код поддержки, нужно самому следить за edge cases и доступностью.

---

## Варианты из практики и из интернета

### 1. Библиотеки с нативной поддержкой touch

| Библиотека | Суть | Плюсы | Минусы |
|------------|------|--------|--------|
| **@dnd-kit** | Не использует HTML5 DnD; свои сенсоры: Pointer, Mouse, Touch, Keyboard. ~10kb, React-first. | Единый код для мыши и touch, задержка/допуск для TouchSensor (delay, tolerance), доступность, Sortable preset. | Нужно переписать кастомайзер под `DndContext` / `useDraggable` / `useDroppable`. |
| **React DnD** | Классический DnD с бэкендами. | Есть **Touch Backend** отдельно от HTML5. | Два бэкенда (mouse + touch), больше бандл, API сложнее. |
| **React Aria (useDragAndDrop)** | Компоненты/хуки от Adobe. | Мышь, touch, клавиатура, screen readers из коробки. | Завязка на React Aria, другой стиль API. |
| **SortableJS** | Ванilla JS, обёртки под React/Vue. | Touch, drag handle, анимации, автоскролл. | Не React-native, нужна обвязка под наш layout (полоски между блоками, «в одну строку» только на десктопе). |

**Идея:** взять одну библиотеку (например, **dnd-kit** или **React DnD + Touch Backend**) и вести весь кастомайзер через неё — и мышь, и touch будут работать из одного места. Текущий long-press + touch можно тогда убрать.

---

### 2. Pointer Events вместо раздельных mouse/touch

**Pointer Events API** (`pointerdown` / `pointermove` / `pointerup`) даёт один тип событий и для мыши, и для touch (и пера). Логику перетаскивания можно писать один раз, проверяя `pointerType === 'touch'` только там, где нужна разница (например, задержка перед стартом).

- Плюсы: один код, хорошая поддержка в современных браузерах.
- Минусы: всё равно своя реализация DnD (как сейчас с touch), нужно самому обрабатывать активацию (задержка для touch), drop-зоны и т.д.

Текущий подход можно постепенно перевести на Pointer Events вместо отдельных `touchstart`/`touchmove`/`touchend` — это упростит код и подготовит к перам/тачпадам.

---

### 3. Паттерн «Pick then place» (выбрал → прокрутил → поставил)

Вместо «удержал и повёл пальцем» используется **двухшаговый сценарий**:

1. Пользователь **выбирает** элемент (тап/долгое нажатие) — элемент визуально «поднимается» (ghost, overlay).
2. При необходимости **скроллит** список.
3. **Тапает** по месту, куда вставить — элемент «ставится» в эту позицию.

Так делают, например, **picknplace.js** и ряд мобильных интерфейсов.

- Плюсы: нет конфликта со скроллом, проще попасть в нужное место на маленьком экране, меньше случайных перетаскиваний.
- Минусы: другой UX (не «перетащил», а «выбрал и указал место»), нужно явно показывать режим «выбран один блок, выберите место».

Подходит, если решите, что «настоящий» drag на touch не обязателен и приоритет — удобство и предсказуемость на мобильном.

---

### 4. Упрощение UX только для мобильных

Альтернатива перетаскиванию:

- Кнопки **«Выше» / «Ниже»** у каждого блока в кастомайзере на мобильных — без drag, только тапы.
- Или **модалка «Изменить порядок»** со списком и теми же кнопками вверх/вниз.

Плюсы: работает везде, не зависит от touch/DnD, доступность проще. Минусы: больше тапов при большом количестве блоков.

---

## Рекомендации

1. **Оставить текущую схему (long-press + touch)** — разумный компромисс без новых зависимостей. Имеет смысл доработать:
   - подсказку («удержите ~0.5 сек»),
   - размер зон сброса (полоски),
   - при желании — переход на Pointer Events для единого кода с мышью.

2. **Если нужна одна библиотека для мыши и touch и готовы переписать кастомайзер** — логичный выбор **@dnd-kit**: встроенные Touch/Pointer сенсоры, задержка активации, без HTML5 DnD, подходит под список с drop-зонами между элементами.

3. **Если приоритет — минимум конфликтов со скроллом и простой мобильный UX** — рассмотреть паттерн **«pick then place»** (выбор блока → скролл → тап по месту) или кнопки **«Выше»/«Ниже»** только на мобильных.

4. **Pointer Events** — полезное улучшение текущей реализации (один набор обработчиков вместо дублирования mouse + touch), не обязательно менять библиотеку.

---

## Ссылки

- [dnd-kit — Overview](https://docs.dndkit.com/) (архитектура без HTML5 DnD, сенсоры Touch/Pointer)
- [dnd-kit — Sensors](https://docs.dndkit.com/api-documentation/sensors) (TouchSensor: delay, tolerance)
- [React DnD — Touch Backend](https://react-dnd.github.io/react-dnd/docs/backends/touch)
- [React Aria — useDrop / Drag and Drop](https://react-spectrum.adobe.com/react-aria/dnd.html)
- [SortableJS](https://sortablejs.github.io/Sortable/) (touch, списки)
- [Nielsen Norman Group — Drag–and–Drop](https://www.nngroup.com/articles/drag-drop/)
- [MDN — Pointer events](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events)
- [picknplace.js](https://www.cssscript.com/drag-drop-alternative-picknplace/) (mobile-first pick-then-place)
