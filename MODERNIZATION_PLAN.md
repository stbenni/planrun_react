# План модернизации проекта vladimirov

План составлен по результатам анализа кодовой базы и актуальной документации (React, Vite, React Router, Zustand). Цель — поэтапно обновить зависимости и перейти на более современные паттерны без поломки текущего функционала.

---

## Зачем и почему вообще модернизировать

**Зачем:** чтобы приложение оставалось поддерживаемым, безопасным и готовым к новым фичам — без «техдолга» из устаревших версий и паттернов.

**Почему сейчас имеет смысл:**
- Текущий стек уже современный (React 18, Vite 5, хуки), но вышли новые мажорные версии (React 19, Vite 6) с улучшениями и исправлениями.
- Чем дольше откладывать обновление, тем сложнее и рискованнее будет миграция позже.
- Часть изменений (lazy, тема, рефакторинг загрузки данных) уменьшает дублирование и упрощает код — проще добавлять новый функционал и искать баги.

**Почему поэтапно:** один большой апгрейд всего сразу рискован (сложно искать причину регрессий). Небольшие этапы с проверкой после каждого снижают риск и позволяют откатиться точечно при проблемах.

---

## Текущее состояние (кратко)

- **React 18.2**, функциональные компоненты, хуки
- **Vite 5.4**, **React Router 6.20**, **Zustand 5**
- Классовых компонентов и устаревших API (defaultProps, PropTypes, старый рендер) нет
- Lazy + Suspense используются для части экранов

---

## Этап 1. Подготовка и низкорисковые правки

**Зачем:** уменьшить разброс подходов в коде и подготовить базу к возможному переходу на React 19 без смены мажорной версии.

**Почему именно эти задачи:**
- **1.1** — Сейчас AdminScreen грузится через ручной `useState` + `useEffect` + `import().then()`, а остальные экраны — через `React.lazy()`. Один способ lazy по всему проекту проще понимать и менять; меньше кастомной логики.
- **1.2** — Два отдельных `<script>` с темой в index.html делают одно и то же (чтение темы, применение, подписка на `prefers-color-scheme`). Один блок — меньше расхождений при правках и меньше шанс забыть обновить одно из мест.
- **1.3** — React 18.3 содержит предупреждения об устаревших API и совместим с путём на React 19. Обновление до 18.3 сначала снижает риск при последующем переходе на 19.

| # | Задача | Действия | Приоритет |
|---|--------|----------|-----------|
| 1.1 | Унификация lazy-загрузки AdminScreen | Заменить `AdminTabPlaceholder` (useState + useEffect + dynamic import) на `React.lazy(() => import('../screens/AdminScreen'))` и рендер внутри существующего Suspense | Низкий |
| 1.2 | Скрипты темы в index.html | Объединить два блока инициализации темы в один (устранение дублирования) | Низкий |
| 1.3 | Обновление до React 18.3.x | `npm install react@^18.3.0 react-dom@^18.3.0`, прогнать приложение и тесты, при необходимости — codemod'ы из react-codemod для подготовки к React 19 | Средний |

**Результат этапа:** стабильная база на React 18.3, меньше дублирования кода.

---

## Этап 2. Обновление инструментов сборки

**Зачем:** получать актуальные исправления и оптимизации Vite, современные дефолты по целевым браузерам и не отставать от экосистемы плагинов.

**Почему именно эти задачи:**
- **2.1** — Vite 6 официально не поддерживает Node 18; сборка на неподдерживаемой версии Node может вести себя непредсказуемо или сломаться в следующих патчах.
- **2.2** — Новая мажорная версия Vite меняет дефолты (например, `build.target`), убирает устаревшие опции и улучшает производительность. Опция `future` в конфиге позволяет заранее включить часть изменений и увидеть предупреждения до полного перехода.
- **2.3** — После смены версии сборки нужно убедиться, что dev, production-сборка, прокси к API и мобильная сборка (Capacitor) по-прежнему работают.

| # | Задача | Действия | Приоритет |
|---|--------|----------|-----------|
| 2.1 | Проверка окружения для Vite 6 | Убедиться, что Node.js 20.19+ или 22.12+ (Vite 6 не поддерживает Node 18) | Обязательно перед 2.2 |
| 2.2 | Миграция на Vite 6 | Обновить `vite` и `@vitejs/plugin-react` до версий, совместимых с Vite 6; при необходимости включить в конфиге `future: { … }` для плавного перехода; проверить `build.target` и поддержку браузеров | Средний |
| 2.3 | Проверка сборки и dev-сервера | Прогнать `npm run build`, `npm run dev`, проверить прокси к `/api`, мобильную сборку (Capacitor) | Обязательно |

**Результат этапа:** сборка на Vite 6, актуальные дефолты по целевым браузерам.

---

## Этап 3. Переход на React 19 (опционально)

**Зачем:** использовать новый хук `use()`, улучшенный Suspense и отказ от части устаревших API — код загрузки данных становится проще, меньше ручного состояния loading/error.

**Почему опционально:** текущее приложение нормально работает на React 18; переход на 19 — улучшение, а не необходимость. Имеет смысл делать после этапов 1–2, когда база уже стабильна.

**Почему именно эти задачи:**
- **3.1–3.2** — Мажорное обновление React может затронуть типы и поведение; проверка совместимости и исправление предупреждений снижают риск регрессий.
- **3.3** — `use(promise)` в рендере + кэш запросов заменяет типичную связку useEffect + useState + флаги загрузки/ошибки. Меньше кода, данные естественно интегрируются с Suspense (один fallback на границе вместо множества локальных спиннеров).

| # | Задача | Действия | Приоритет |
|---|--------|----------|-----------|
| 3.1 | Обновление React и React DOM | `npm install react@^19.0.0 react-dom@^19.0.0` (при необходимости — обновить типы, если появится TypeScript) | Низкий |
| 3.2 | Проверка совместимости | Убедиться, что новый JSX transform используется везде; проверить предупреждения в консоли и исправить deprecated API | Низкий |
| 3.3 | Внедрение use() для части запросов | Выбрать 1–2 сценария (например, настройки сайта в App, загрузка данных одного экрана), ввести кэш запросов и чтение через `use(promise)` в компоненте с обёрткой в Suspense | Низкий |

**Результат этапа:** React 19, при желании — современный паттерн загрузки данных через `use()` и Suspense.

---

## Этап 4. Роутинг и загрузка данных (по желанию)

**Зачем:** загрузка данных на уровне маршрута (loaders) и единый способ lazy-маршрутов делают поведение предсказуемым: данные готовы до первого рендера экрана, меньше «миганий» и дублирования логики загрузки в каждом компоненте.

**Почему по желанию:** текущая схема (данные в useEffect внутри экранов) рабочая. Переход на createBrowserRouter + loaders — смена архитектуры; выгоден при активном добавлении новых разделов или при рефакторинге навигации.

**Почему именно эти задачи:**
- **4.1** — Документация React Router описывает loaders и lazy в связке; без понимания API легко допустить ошибки при миграции.
- **4.2** — Один пилотный маршрут позволяет проверить интеграцию с текущим роутингом и состоянием (Zustand, auth) без переписывания всего приложения.
- **4.3** — Постепенный перенос маршрутов снижает объём изменений за один раз и упрощает откат при проблемах.

| # | Задача | Действия | Приоритет |
|---|--------|----------|-----------|
| 4.1 | Знакомство с createBrowserRouter | Изучить документацию React Router по loaders и lazy-маршрутам | Низкий |
| 4.2 | Пилотный маршрут с loader | Выбрать один маршрут (например, профиль пользователя или настройки), перевести на `createBrowserRouter` + `lazy` + `loader`, в компоненте использовать `useLoaderData()` | Низкий |
| 4.3 | Постепенная миграция остальных маршрутов | Переносить по одному маршруту на новую схему без «большого взрыва» | Низкий |

**Результат этапа:** единообразная загрузка данных на уровне роутера, меньше разрозненных useEffect под каждый экран.

---

## Этап 5. Дополнительно (по мере необходимости)

**Зачем:** поддерживать инструменты и код в актуальном виде без срочности — когда будете трогать соответствующие части проекта.

**Почему именно эти задачи:**
- **5.1** — ESLint 9 и flat config — рекомендуемое направление развития ESLint; старый config формата со временем может устареть. Имеет смысл при следующем обновлении линтера.
- **5.2** — ApiClient уже неплохо структурирован; вынос повторяющейся логики (refresh, retry) и явное разделение хранилища токенов упрощают тесты и возможную поддержку React Native.
- **5.3** — Capacitor часто обновляется под новые версии Android/iOS; сверка с changelog при обновлении зависимостей помогает избежать несовместимостей с нативным окружением.

| # | Задача | Действия | Приоритет |
|---|--------|----------|-----------|
| 5.1 | ESLint 9 + flat config | При обновлении ESLint перейти на flat config (eslint.config.js) | Низкий |
| 5.2 | Рефакторинг ApiClient | Вынести повторяющуюся логику (refresh token, retry при 401) в отдельные функции; явно разделить слой хранилища токенов (web vs native), если появится React Native | Низкий |
| 5.3 | Capacitor | При обновлении зависимостей сверять версии с официальным changelog Capacitor | По необходимости |

---

## Порядок выполнения (рекомендуемый)

**Почему такой порядок:** сначала правки без смены версий (этап 1) — нулевой риск для зависимостей. Потом обновление сборки (этап 2) — одна зона изменений, легко проверить. Этапы 3 и 4 зависят от желания команды и могут идти в любом порядке или выборочно. Этап 5 — когда будете трогать соответствующий код.

1. **Сначала:** Этап 1 (правки без смены версий).
2. **Затем:** Этап 2 (Vite 6), после проверки Node и тестов.
3. **По желанию:** Этапы 3 и 4 — в любом порядке или только выборочно.
4. Этап 5 — по мере необходимости.

---

## Чек-лист перед каждым релизом после изменений

- [ ] `npm run build` без ошибок
- [ ] `npm run dev`, проверка основных сценариев в браузере
- [ ] Проверка входа/выхода, JWT и сессии
- [ ] Проверка мобильной сборки (Capacitor), если используется
- [ ] Нет новых предупреждений в консоли (React, Vite, ESLint)
